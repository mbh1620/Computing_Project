<html>
<head>
<title>3D Model Viewer</title>
<link rel='stylesheet' href='style.css'>
</head>
<body>

<h1 style='font-family: helvetica'>3D Model Viewer</h1>

<canvas id='c' style='height:600;width:auto'></canvas>
</br>
<label style='font-family: helvetica'>Choose file to upload</label>
<input type='file'>
<h3>Materials</h3>
<ul style='list-style-type: none'>
<li><input type='color' value='#b87373'>Copper</li>
<li><input type='color' value='#bcbcbc'>Aluminium</li>
<li><input type='color' value='#43464B'>Steel</li>
</ul>
<h3>Cells</h3>
<h3>Vectors</h3>
<ul>
<li>
</ul>
<script src='js/three.js'></script>
<script src='js/OrbitControls.js'></script>

<script>
function main() {
const canvas = document.querySelector('#c');
const renderer = new THREE.WebGLRenderer({canvas});
const fov = 75;
const aspect = 2;  // the canvas default
const near = 0.1;
const far = 100;
const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
camera.position.z = 5;
const scene = new THREE.Scene();
var controls = new THREE.OrbitControls(camera, renderer.domElement);
meshfloor = new THREE.Mesh(
new THREE.PlaneGeometry(20,20,10,10),
new THREE.MeshBasicMaterial({color:0xFFFFFF, wireframe:true})
)
meshfloor.rotation.x += Math.PI / 2;
scene.add(meshfloor);
{
const color = 0xFFFFFF;
const intensity = 1;
const light = new THREE.DirectionalLight(color, intensity);
light.position.set(-1, 2, 4);
scene.add(light);
}
function makeInstancet(geometry, color, x) {
const material = new THREE.MeshBasicMaterial({color});
const tetra = new THREE.Mesh(geometry, material);
scene.add(tetra);
tetra.position.x = x;
return tetra;
}


const tetras = [

];
const geometry_h0 = new THREE.Geometry();
geometry_h0.vertices.push(
new THREE.Vector3(0,0,2),  // 0
new THREE.Vector3(2,0,2),  // 0
new THREE.Vector3(0,2,2),  // 0
new THREE.Vector3(2,2,2),  // 0
new THREE.Vector3(0,0,0),  // 0
new THREE.Vector3(2,0,0),  // 0
new THREE.Vector3(0,2,0),  // 0
new THREE.Vector3(2,2,0),  // 0
);

geometry_h0.faces.push(
// front
new THREE.Face3(0, 3, 2),
new THREE.Face3(0, 1, 3),
// right
new THREE.Face3(1, 7, 3),
new THREE.Face3(1, 5, 7),
// back
new THREE.Face3(5, 6, 7),
new THREE.Face3(5, 4, 6),
// left
new THREE.Face3(4, 2, 6),
new THREE.Face3(4, 0, 2),
// top
new THREE.Face3(2, 7, 6),
new THREE.Face3(2, 3, 7),
// back
new THREE.Face3(4, 1, 0),
new THREE.Face3(4, 5, 1),
);
function makeInstanceh(geometry, color, x) {
const material = new THREE.MeshBasicMaterial({color});
const hexa = new THREE.Mesh(geometry, material);
scene.add(hexa);
hexa.position.x = x;
return hexa;
}


const hexas = [

makeInstanceh(geometry_h0, 0xb87373, 0),

];
function resizeRendererToDisplaySize(renderer) {
const canvas = renderer.domElement;
const width = canvas.clientWidth;
const height = canvas.clientHeight;
const needResize = canvas.width !== width || canvas.height !== height;
if (needResize) {
  renderer.setSize(width, height, false);
}
return needResize;
}
function render(time) {
time *= 0.001;
if (resizeRendererToDisplaySize(renderer)) {
const canvas = renderer.domElement;
camera.aspect = canvas.clientWidth / canvas.clientHeight;
camera.updateProjectionMatrix();
}
tetras.forEach((tetra, ndx) => {
const speed = 1 + ndx * .1;
const rot = time * speed;
tetra.rotation.x = 0;
tetra.rotation.y = 0;
});
hexas.forEach((hexa, ndx) => {
const speed = 1 + ndx * .1;
const rot = time * speed;
hexa.rotation.x = 0;
hexa.rotation.y = 0;
});
renderer.render(scene, camera);
requestAnimationFrame(render);
}
requestAnimationFrame(render);
}
main();
</script>
</body>
</html>
