<html>
<head>
<title>3D Model Viewer</title>
<link rel='stylesheet' href='style.css'>
</head>
<body>

<h1 style='font-family: helvetica'>3D Model Viewer</h1>

<canvas id='c' style='height:600;width:auto'></canvas>
</br>
<label style='font-family: helvetica'>Choose file to upload</label>
<input type='file'>
<h3>Materials</h3>
<ul style='list-style-type: none'>
<li><input type='color' value='#757575'>Aluminium</li>
<li><input type='color' value='#cc9316'>Copper</li>
<li><input type='color' value='#bababa'>Steel</li>
</ul>
<h3>Cells</h3>
<h3>Vectors</h3>
<ul>
<li>
</ul>
<script src='js/three.js'></script>
<script src='js/OrbitControls.js'></script>

<script>
function main() {
const canvas = document.querySelector('#c');
const renderer = new THREE.WebGLRenderer({canvas});
const fov = 75;
const aspect = 2;  // the canvas default
const near = 0.1;
const far = 100;
const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
camera.position.z = 5;
const scene = new THREE.Scene();
var controls = new THREE.OrbitControls(camera, renderer.domElement);
meshfloor = new THREE.Mesh(
new THREE.PlaneGeometry(20,20,10,10),
new THREE.MeshBasicMaterial({color:0xFFFFFF, wireframe:true})
)
meshfloor.rotation.x += Math.PI / 2;
scene.add(meshfloor);
{
const color = 0xFFFFFF;
const intensity = 1;
const light = new THREE.DirectionalLight(color, intensity);
light.position.set(-1, 2, 4);
scene.add(light);
}

const geometry0 = new THREE.Geometry();
geometry0.vertices.push(
new THREE.Vector3(0,0,0),  // 0
new THREE.Vector3(1,0,0),  // 0
new THREE.Vector3(0.5,0,1),  // 0
new THREE.Vector3(0.5,1,0),  // 0
);

geometry0.faces.push(
new THREE.Face3(0, 3, 1),
new THREE.Face3(1, 2, 3),
new THREE.Face3(1, 3, 2),
new THREE.Face3(0, 2, 3),
new THREE.Face3(0, 1, 2),
);
const geometry1 = new THREE.Geometry();
geometry1.vertices.push(
new THREE.Vector3(0,0,1),  // 0
new THREE.Vector3(1,1,1),  // 0
new THREE.Vector3(0.5,0,1),  // 0
new THREE.Vector3(0.5,1,0),  // 0
);

geometry1.faces.push(
new THREE.Face3(0, 3, 1),
new THREE.Face3(1, 2, 3),
new THREE.Face3(1, 3, 2),
new THREE.Face3(0, 2, 3),
new THREE.Face3(0, 1, 2),
);
const geometry2 = new THREE.Geometry();
geometry2.vertices.push(
new THREE.Vector3(0,0,0),  // 0
new THREE.Vector3(0.5,0,1),  // 0
new THREE.Vector3(1,0,0),  // 0
new THREE.Vector3(0.5,1,0),  // 0
);

geometry2.faces.push(
new THREE.Face3(0, 3, 1),
new THREE.Face3(1, 2, 3),
new THREE.Face3(1, 3, 2),
new THREE.Face3(0, 2, 3),
new THREE.Face3(0, 1, 2),
);
function makeInstance(geometry, color, x) {
const material = new THREE.MeshBasicMaterial({color});
const tetra = new THREE.Mesh(geometry, material);
scene.add(tetra);
tetra.position.x = x;
return tetra;
}


const tetras = [

makeInstance(geometry0, 0x44FF44, 0),

makeInstance(geometry1, 0x44FF44, 0),

makeInstance(geometry2, 0x44FF44, 0),

];
function resizeRendererToDisplaySize(renderer) {
const canvas = renderer.domElement;
const width = canvas.clientWidth;
const height = canvas.clientHeight;
const needResize = canvas.width !== width || canvas.height !== height;
if (needResize) {
  renderer.setSize(width, height, false);
}
return needResize;
}
function render(time) {
time *= 0.001;
if (resizeRendererToDisplaySize(renderer)) {
const canvas = renderer.domElement;
camera.aspect = canvas.clientWidth / canvas.clientHeight;
camera.updateProjectionMatrix();
}
tetras.forEach((tetra, ndx) => {
const speed = 1 + ndx * .1;
const rot = time * speed;
tetra.rotation.x = 0;
tetra.rotation.y = 0;
});
renderer.render(scene, camera);
requestAnimationFrame(render);
}
requestAnimationFrame(render);
}
main();
</script>
</body>
</html>
